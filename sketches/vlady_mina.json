{
  "version": "1.4.1",
  "revision": 44,
  "count": {
    "sketches": 1,
    "folders": 0
  },
  "structure": [
    {
      "type": "sketch",
      "name": "vlady-mina",
      "mod": 1673392591934,
      "code": "let credits = {\n\t\"student_names\": \"Vladyslav Solonyi, Mina BogdanoviÄ‡\",\n\t\"recode_id\": \"zotero2-2604593.YIUX4C4M\",\n\t\"recode_timestamp\": 0,\n\t\"recode_title\": \"Countdown, Selbstportrait, Namen - Felix\",\n\t\"recode_designer\": \"Felix Walder\",\n\t\"recode_year\": 2020\n}\nlet libs = [\n\t\"https://unpkg.com/ml5@latest/dist/ml5.min.js\"\n]\n\nlet mirrowOutput = false;\nlet showWebcam = true;\nlet printOneDetection = true;\n\nlet maskk\n\nlet faceapi;\nlet video;\nlet detections;\n\nlet detection_options = {\n\twithLandmarks: true,\n\twithDescriptors: false,\n\tminConfidence: 0.15\n};\n\n//OFFSET\nlet vO = 0\n\n//CONTROLS\nlet sliderBG,\n\tsliderSpeed,\n\tsliderSize,\n\tsliderPosition,\n\tchangeDirection,\n\tsliderTrace,\n\tdirectionValue = 0,\n\tfc = 0,\n\tsliderRotate,\n\trotateValue,\n\trotateRandom = 0,\n\tbwButton,\n\tbwValue = 0,\n\tsurpriseButton,\n\tsurprise = 0\n\nlet guiHolder\n\n\n//TEXT\nlet s = ['5', '4', '3', '2', '1', '0'];\nlet i = 0\n\n//COLORS\nlet colorBG, saturationBG, brightnessBG, brightnessSec\n\nfunction setup() {\n\tcreateCanvas(windowWidth, windowHeight)\n\tcolorMode(HSB)\n\tmaskk = createGraphics(width, height)\n\tvO = width / 4;\n\n\tguiHolder = createDiv()\n\t\t.class('guiHolder')\n\n\tcreateElement('style', ` \n  *{ \n    outline: none; \n    box-sizing: border-box; \n    width: 15%;\n    background: rgba(0, 0, 0, 0.2)\n  } \n    .guiHolder{ \n      position: fixed; \n      right: 50px; \n      top: 50px; \n      border: 1px solid black; \n      padding: 20px;\n    } \n    .label{ \n      color:#fff; \n      font-family:sans-serif; \n      font-size:10pt; \n      text-decoration:underline; \n      padding:5px; \n    } \n    .slider{ \n      width: 100%; \n      margin: 2%;\n    } \n    `)\n\n\t//SLIDERS\n\n\tsliderBG = createSlider(1, 360, 1, 1).parent(guiHolder).class('slider')\n\n\tsliderTrace = createSlider(0, 1, .1, .01).parent(guiHolder).class('slider')\n\n\tsliderSpeed = createSlider(0, 700, 10, .1).parent(guiHolder).class('slider')\n\n\tsliderSize = createSlider(0, 4, 1.4, .1).parent(guiHolder).class('slider')\n\n\tsliderPosition = createSlider(0, height, height / 2 + height / 20, .1).parent(guiHolder).class('slider')\n\n\tsliderRotate = createSlider(0, 360, 0, 1).parent(guiHolder).class('slider')\n\n\t//BUTTONS\n\n\tchangeDirection = createButton('?').parent(guiHolder).class('slider')\n\tbwButton = createButton('?').parent(guiHolder).class('slider')\n\tsurpriseButton = createButton('surprise').parent(guiHolder).class('slider')\n}\n\n\n\nfunction draw() {\n\trotateValue = sliderRotate.value()\n\tcolorBG = sliderBG.value()\n\tsaturationBG = 0\n\tbrightnessBG = 100\n\n\tchangeDirection.mousePressed(() => {\n\t\tdirectionValue++\n\t})\n\tsliderRotate.mousePressed(() => {\n\t\trotateRandom++\n\t})\n\tbwButton.mousePressed(() => {\n\t\tbwValue++\n\t\tcolorBG = sliderBG.value(random(1, 360))\n\t})\n\n\tif(bwValue % 2) {\n\t\tsaturationBG = 100\n\t} else {\n\t\tbrightnessBG = map(colorBG, 1, 360, 0, 100);\n\t\tsaturationBG = 0\n\t\tbrightnessSec = 100 - brightnessBG\n\t}\n\n\tfc += sliderSpeed.value()\n\ttextAlign(CENTER, CENTER)\n\tbackground(colorBG, saturationBG, brightnessBG, sliderTrace.value())\n\tfill(360 - colorBG, saturationBG, brightnessSec);\n\ttextSize(height * sliderSize.value())\n\ttextStyle(BOLD)\n\n\n\tif(fc > (width / 2) + vO) {\n\t\ti++\n\t\tfc = (-width / 2) - vO\n\t\tif(rotateRandom != 0) {\n\t\t\trotateValue = sliderRotate.value()\n\t\t} else {\n\t\t\trotateValue = sliderRotate.value(random(1, 360))\n\t\t}\n\n\t}\n\n\tpush()\n\ttranslate(width / 2, sliderPosition.value())\n\trotate(radians(rotateValue))\n\tif(directionValue % 2 == 0) {\n\t\ttext(s[i % s.length], fc, 0)\n\t} else if(directionValue % 2 != 0) {\n\t\ttext(s[i % s.length], (vO * 2 - (width / 2)) - fc, 0)\n\t}\n\tpop()\n\n\tsurpriseButton.mousePressed(() => {\n\t\tsurprise++\n\t\tif(surprise % 2) {\n\t\t\tvideo = createCapture(VIDEO, function() {\n\t\t\t\tvideo.hide();\n\t\t\t\tfaceapi = ml5.faceApi(video, detection_options, modelReady);\n\t\t\t});\n\t\t} else {\n\t\t\tvideo.remove();\n\t\t}\n\t})\n}\n\nfunction modelReady() {\n\tconsole.log(\"model ready!\");\n\tfaceapi.detect(gotResults);\n}\n\nfunction gotResults(err, result) {\n\tif(err) {\n\t\tconsole.log(err);\n\t\treturn;\n\t}\n\tif(surprise % 2) {\n\t\tdetections = result;\n\t\tbackground(0);\n\n\t\t// background(220);\n\n\t\tif(detections) {\n\t\t\tif(detections.length > 0) {\n\t\t\t\tfor(let i = 0; i < detections.length; i++) {\n\t\t\t\t\tconst alignedRect = detections[i].alignedRect;\n\t\t\t\t\tconst x = alignedRect._box._x;\n\t\t\t\t\tconst y = alignedRect._box._y;\n\t\t\t\t\tconst boxWidth = alignedRect._box._width;\n\t\t\t\t\tconst boxHeight = alignedRect._box._height;\n\t\t\t\t\tfill(255);\n\t\t\t\t\trectMode(CENTER);\n\t\t\t\t\trect(x * ((width / height) * 1.65), y * (width / height), boxWidth * ((width / height) * 1.65), boxHeight * ((width / height) * 1.65));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tdrawingContext.save();\n\t\t\tdrawingContext.clip();\n\t\t\timage(video, 0, 0, width, height)\n\t\t\tdrawingContext.restore();\n\t\t}\n\t\tfaceapi.detect(gotResults);\n\t}\n}"
    }
  ]
}