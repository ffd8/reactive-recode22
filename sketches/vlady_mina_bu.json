{
  "version": "1.4.1",
  "revision": 44,
  "count": {
    "sketches": 1,
    "folders": 0
  },
  "structure": [
    {
      "type": "sketch",
      "name": "ml5-faceapi-tiny_002",
      "mod": 1673014098191,
      "code": "let credits = {\n\t\"student_names\": \"Vladyslav Solonyi, Mina BogdanoviÄ‡\",\n\t\"recode_id\": \"zotero2-2604593.YIUX4C4M\",\n\t\"recode_timestamp\": 0,\n\t\"recode_title\": \"Countdown, Selbstportrait, Namen - Felix\",\n\t\"recode_designer\": \"Felix Walder\",\n\t\"recode_year\": 2020\n}\n\nlet libs = [\n\t// \"data/js/ml5.min.js\" // custom tiny face build (fails)\n\t\"data/Vlady_Mina/ml5.min_old.js\" // 0.5.0 local (works)\n\t// \"https://unpkg.com/ml5@0.5.0/dist/ml5.min.js\" // 0.5.0 remote (works)\n\t// \"https://unpkg.com/ml5@0.4.3/dist/ml5.min.js\" // 0.4.3 remote (works)\n]\n\nlet mirrowOutput = false;\nlet showWebcam = true;\nlet printOneDetection = true;\n\nlet maskk\n\nlet faceapi;\nlet video;\nlet detections;\n\nlet detection_options = {\n\twithLandmarks: true,\n\twithDescriptors: false,\n\tminConfidence: 0.15\n};\n\n//OFFSET\nlet vO=0\n\n//CONTROLS\nlet sliderBG,\n\tsliderSpeed,\n\tsliderSize,\n\tsliderPosition,\n\tchangeDirection,\n\tsliderTrace,\n\tdirectionValue = 0,\n\tfc = 0,\n\tsliderRotate,\n\trotateValue,\n\trotateRandom=0,\n\tbwButton,\n\tbwValue = 0,\n\tsurpriseButton,\n\tsurprise=0\n\t\n\tlet guiHolder\n\t\n\n//TEXT\nlet s = ['5', '4', '3', '2', '1', '0'];\nlet i = 0\n\n//COLORS\nlet colorBG, saturationBG, brightnessBG, brightnessSec\n\nfunction setup() {\n\tcreateCanvas(windowWidth, windowHeight)\n\tcolorMode(HSB)\n\tmaskk = createGraphics(width,height)\n\tvO = width/4;\n\t\n\tguiHolder = createDiv()\n\t\t.class('guiHolder')\n\n\tcreateElement('style', ` \n  *{ \n    outline: none; \n    box-sizing: border-box; \n    width: 15%;\n    background: rgba(0, 0, 0, 0.2)\n  } \n    .guiHolder{ \n      position: fixed; \n      right: 50px; \n      top: 50px; \n      border: 1px solid black; \n      padding: 20px;\n    } \n    .label{ \n      color:#fff; \n      font-family:sans-serif; \n      font-size:10pt; \n      text-decoration:underline; \n      padding:5px; \n    } \n    .slider{ \n      width: 100%; \n      margin: 2%;\n    } \n    `)\n\n\t//SLIDERS\n\n\tsliderBG = createSlider(1, 360, 1, 1).parent(guiHolder).class('slider')\n\n\tsliderTrace = createSlider(0, 1, .1, .01).parent(guiHolder).class('slider')\n\n\tsliderSpeed = createSlider(0, 700, 10, .1).parent(guiHolder).class('slider')\n\n\tsliderSize = createSlider(0, 4, 1.4, .1).parent(guiHolder).class('slider')\n\n\tsliderPosition = createSlider(0, height, height/2+height/20, .1).parent(guiHolder).class('slider')\n\n\tsliderRotate = createSlider(0, 360, 0, 1).parent(guiHolder).class('slider')\n\n\t//BUTTONS\n\n\tchangeDirection = createButton('?').parent(guiHolder).class('slider')\n\tbwButton = createButton('?').parent(guiHolder).class('slider')\n\tsurpriseButton = createButton('surprise').parent(guiHolder).class('slider')\n}\n\n\n\nfunction draw() {\n\trotateValue=sliderRotate.value()\n\tcolorBG = sliderBG.value()\n\tsaturationBG = 0\n\tbrightnessBG = 100\n\n\tchangeDirection.mousePressed(() => {\n\t\tdirectionValue++\n\t})\n\tsliderRotate.mousePressed(() => {\n\t\trotateRandom++\n\t})\n\tbwButton.mousePressed(() => {\n\t\tbwValue++\n\t\tcolorBG=sliderBG.value(random(1,360))\n\t})\n\t\n\tif(bwValue % 2) {\n\t\tsaturationBG=100\n\t}\n\telse{\n\t\tbrightnessBG=map(colorBG,1,360,0,100);\n\t\tsaturationBG=0\n\t\tbrightnessSec=100-brightnessBG\n\t}\n\n\tfc += sliderSpeed.value()\n\ttextAlign(CENTER, CENTER)\n\tbackground(colorBG, saturationBG, brightnessBG, sliderTrace.value())\n\tfill(360 - colorBG, saturationBG, brightnessSec);\n\ttextSize(height*sliderSize.value())\n\ttextStyle(BOLD)\n\n\n\tif(fc > (width / 2)+vO) {\n\t\ti++\n\t\tfc = (-width / 2)-vO\n\t\tif(rotateRandom != 0) {\n\t\trotateValue=sliderRotate.value()\n\t}else{rotateValue=sliderRotate.value(random(1,360))}\n\t\t\n\t}\n\npush()\n\ttranslate(width / 2, sliderPosition.value())\n\trotate(radians(rotateValue))\n\tif(directionValue % 2 == 0) {\n\t\ttext(s[i % s.length], fc, 0)\n\t} else if(directionValue % 2 != 0) {\n\t\ttext(s[i % s.length], (vO*2-(width/2)) - fc, 0)\n\t}\npop()\n\nsurpriseButton.mousePressed(()=>{\n\t\tsurprise++\n\t\tif(surprise%2){\n\tvideo = createCapture(VIDEO, function() {\n\tvideo.hide();\n\tfaceapi = ml5.faceApi(video, detection_options, modelReady);});\n}else{\n\tvideo.remove();}\n\t})\n}\n\nfunction modelReady() {\n\tconsole.log(\"model ready!\");\n\tfaceapi.detect(gotResults);\n}\n\nfunction gotResults(err, result) {\n\tif(err) {\n\t\tconsole.log(err);\n\t\treturn;\n\t}\nif(surprise%2){\n\tdetections = result;\n\tbackground(0);\n\n\t// background(220);\n\t\n\tif(detections) {\n\t\tif(detections.length > 0) {\n\t\tfor(let i = 0; i < detections.length; i++) {\n\t\tconst alignedRect = detections[i].alignedRect;\n\t\tconst x = alignedRect._box._x;\n\t\tconst y = alignedRect._box._y;\n\t\tconst boxWidth = alignedRect._box._width;\n\t\tconst boxHeight = alignedRect._box._height;\n\t\tdrawingContext.save();\n\t\tfill(255);\n\t\trect(x*((width/height)*1.65), y*(width/height), boxWidth*((width/height)*1.65), boxHeight*((width/height)*1.65));\n\t\t\n\t}\n\t\t}\n\t\tdrawingContext.clip();\n\t\timage(video,0,0,width,height)\n\t\tdrawingContext.restore();\n\t}\n\tfaceapi.detect(gotResults);}\n}"
    }
  ]
}